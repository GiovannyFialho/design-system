import{j as h}from"./index-DBBjsPzo.js";import{e as p,f as E,d as T}from"./index-BsHNX4v6.js";import{r as O}from"./index-BzhKaBtb.js";import"./_commonjsHelpers-CqkleIqs.js";import"./index-DCY-Pets.js";const{Channel:C}=__STORYBOOK_MODULE_CHANNELS__,{global:l}=__STORYBOOK_MODULE_GLOBAL__,{logger:i}=__STORYBOOK_MODULE_CLIENT_LOGGER__,{STORY_RENDERED:U,UPDATE_STORY_ARGS:w,RESET_STORY_ARGS:S,UPDATE_GLOBALS:$,FORCE_RE_RENDER:G}=__STORYBOOK_MODULE_CORE_EVENTS__;function v(){let e={setHandler:()=>{},send:()=>{}};return new C({transport:e})}var R=class{constructor(){this.getChannel=()=>{if(!this.channel){let e=v();return this.setChannel(e),e}return this.channel},this.getServerChannel=()=>{if(!this.serverChannel)throw new Error("Accessing non-existent serverChannel");return this.serverChannel},this.ready=()=>this.promise,this.hasChannel=()=>!!this.channel,this.hasServerChannel=()=>!!this.serverChannel,this.setChannel=e=>{this.channel=e,this.resolve()},this.setServerChannel=e=>{this.serverChannel=e},this.promise=new Promise(e=>{this.resolve=()=>e(this.getChannel())})}},u="__STORYBOOK_ADDONS_PREVIEW";function k(){return l[u]||(l[u]=new R),l[u]}var y=k(),A=(e,n)=>e.length===n.length&&e.every((t,o)=>t===n[o]),d=()=>new Error("Storybook preview hooks can only be called inside decorators and story functions.");function D(){return l.STORYBOOK_HOOKS_CONTEXT||null}function f(){let e=D();if(e==null)throw d();return e}function x(e,n,t){let o=f();if(o.currentPhase==="MOUNT"){t!=null&&!Array.isArray(t)&&i.warn(`${e} received a final argument that is not an array (instead, received ${t}). When specified, the final argument must be an array.`);let r={name:e,deps:t};return o.currentHooks.push(r),n(r),r}if(o.currentPhase==="UPDATE"){let r=o.getNextHook();if(r==null)throw new Error("Rendered more hooks than during the previous render.");return r.name!==e&&i.warn(`Storybook has detected a change in the order of Hooks${o.currentDecoratorName?` called by ${o.currentDecoratorName}`:""}. This will lead to bugs and errors if not fixed.`),t!=null&&r.deps==null&&i.warn(`${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`),t!=null&&r.deps!=null&&t.length!==r.deps.length&&i.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${r.deps}
Incoming: ${t}`),(t==null||r.deps==null||!A(t,r.deps))&&(n(r),r.deps=t),r}throw d()}function N(e,n,t){let{memoizedState:o}=x(e,r=>{r.memoizedState=n()},t);return o}function c(e,n){return N("useCallback",()=>e,n)}function L(){let{currentContext:e}=f();if(e==null)throw d();return e}function b(){let e=y.getChannel(),{id:n,args:t}=L(),o=c(s=>e.emit(w,{storyId:n,updatedArgs:s}),[e,n]),r=c(s=>e.emit(S,{storyId:n,argNames:s}),[e,n]);return[t,o,r]}const M={title:"Surfaces/Toast",component:p,args:{title:"Título do Toast",description:"Descrição do toast",isOpen:!1,swipeDirection:"right"},argTypes:{swipeDirection:{options:["left","right","up","down"],control:{type:"radio"}}},decorators:[e=>{const[n,t]=b(),o=O.useRef(0),r=c(()=>{t({isOpen:!n.isOpen})},[t,n.isOpen]);O.useEffect(()=>(t({handleChange:r}),()=>clearTimeout(o.current)),[t,r]);function s(){r(),window.clearTimeout(o.current),o.current=window.setTimeout(()=>{r()},3e3)}return h.jsxs(E,{swipeDirection:n.swipeDirection,children:[h.jsx(T,{onClick:s,children:"Ativar Toast"}),h.jsx(e,{})]})}]},a={};var _,g,m;a.parameters={...a.parameters,docs:{...(_=a.parameters)==null?void 0:_.docs,source:{originalSource:"{}",...(m=(g=a.parameters)==null?void 0:g.docs)==null?void 0:m.source}}};const j=["Primary"];export{a as Primary,j as __namedExportsOrder,M as default};
